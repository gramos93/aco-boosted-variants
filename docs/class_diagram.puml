@startuml

class Main {
  create_search_path(): SearchPath
  setup_grid(): GridWorld
  choose_search_algorithm(): ConcreteSearchAlgorithm
  run()
}

class GridWorld {
  grid: 2D Array
  vision: 2D Array
  update()
}

class SearchPath {
  path: List<SearchNode>
  add_node(SearchNode)
  calculate_cost()
  is_valid()
}

class SearchNode {
  coordinates
  cost
  parent
}

class Logger {
  log_info()
  log_error()
}

class UIController {
  updateUI()
}

abstract class SearchAlgorithm {
  world: GridWorld
  path: SearchPath
  controller: UIController
  logger: Logger
  initialize()
  search()
  search_multithreaded()
  get_solution(): SearchPath
  notify_controller()
  notify_logger()
}

class ConcreteSearchAlgorithm {
  world: GridWorld
  path: SearchPath
  controller: UIController
  logger: logger
  initialize()
  search()
  search_multithreaded()
  get_solution(): SearchPath
  notify_controller()
  notify_logger()
}

Main --> ConcreteSearchAlgorithm : Run
SearchAlgorithm <|-- ConcreteSearchAlgorithm
ConcreteSearchAlgorithm --> GridWorld : References
ConcreteSearchAlgorithm --> SearchPath : Updates
ConcreteSearchAlgorithm --> UIController : Notifies
ConcreteSearchAlgorithm --> Logger : Notifies
SearchPath --> SearchNode : Contains
SearchPath --> GridWorld : Feasibility Check

note right of ConcreteSearchAlgorithm
  This class is using the Strategy design pattern, 
  where SearchAlgorithm is an interface to guarantee proper
  interaction with SearchPath.
end note

note right of UIController
  This class is using the Observer design pattern.
  
  UI and logs are currently attached to 
  the search algorithm as opposed
  to the Main (orchestrator class) 
  because logging and display
  may vary between each implementation 
  for ease of debugging.
end note

note right of SearchAlgorithm::search_multithreaded
  This interface allows for a sequential search, or in cases
  where it will be feasible (for example baseline A*) a
  multithreaded search can be done by using
  divide and conquer approach.
end note

@enduml
