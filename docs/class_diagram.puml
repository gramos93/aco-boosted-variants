@startuml

class Main {
  create_search_path(): SearchPath
  setup_grid(): GridWorld
  choose_search_algorithm(): ConcreteSearchAlgorithm
  run()
}

class GridWorld {
  grid: 2D Array
  vision: 2D Array
  update()
}

class SearchPath {
  path: List<SearchNode>
  add_node(SearchNode)
  calculate_cost()
}

class SearchNode {
  coordinates
  cost
  parent
}

class Logger {
  log_info()
  log_error()
}

class UIController {
  updateUI()
}

abstract class SearchAlgorithm {
  controller: UIController
  logger: Logger
  initialize()
  search()
  search_multithreaded()
  get_solution(): SearchPath
  notify_controller()
  notify_logger()
}

class ConcreteSearchAlgorithm {
  controller: UIController
  logger: logger
  initialize()
  search()
  search_multithreaded()
  get_solution(): SearchPath
  notify_controller()
  notify_logger()
}

Main --> GridWorld
Main --> ConcreteSearchAlgorithm
Main  --> SearchPath
SearchPath -[dashed]-> GridWorld
SearchAlgorithm <|-- ConcreteSearchAlgorithm
ConcreteSearchAlgorithm --> UIController
ConcreteSearchAlgorithm --> Logger
SearchPath --> SearchNode

note right of ConcreteSearchAlgorithm
  This class is using the Strategy design pattern, 
  where SearchAlgorithm is an interface to guarantee proper
  interaction with SearchPath.
end note

note right of UIController
  This class is using the Observer design pattern, 
  so we can control running the algorithm headlessly, updating
  every 'n' expanded nodes, etc. We can constrain the update
  frequency for good execution.
  
  UI and logs are currently attached to the search algorithm as opposed
  to the Main (orchestrator class) because logging and display
  may vary between each implementation for ease of debugging.
end note

note right of SearchAlgorithm::search_multithreaded
  This interface allows for a sequential search, or in cases
  where it will be feasible (for example baseline A*) a
  multithreaded search can be done by using
  divide and conquer approach.
end note

@enduml
